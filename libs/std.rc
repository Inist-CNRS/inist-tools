#!/usr/bin/env bash
################################################################################
#
# inist-tools / libs / std.rc
# 
# Bibliothèque de fonctions standards utilisées par le lanceur ou les
# outils « inist-tools ».
#
# @author : INIST-CNRS/DPI
#
################################################################################

#-------------------------------------------------------------------------------
# Initialisation de variables globales
#-------------------------------------------------------------------------------

# TRUE or FALSE ?
TRUE=0
FALSE=1

# PROXY
INIST_HTTP_PROXY="http://proxyout.inist.fr:8080"
INIST_HTTPS_PROXY="https://proxyout.inist.fr:8080"
INIST_FTP_PROXY="http://proxyout.inist.fr:8080"
INIST_PROXYPAC="http://proxypac.intra.inist.fr/proxy.pac"
INIST_NO_PROXY="localhost,127.0.0.0/8,*.local,172.16.0.0/16"
INIST_PROXY_ADDRESS="http://proxyout.inist.fr"
INIST_PROXY_PORT="8080"
INIST_ADSL_PROXYPAC="http://proxypac.intra.inist.fr/proxy.pac"

# ICONS
ICON_CNRS="$DIR_LIBS/gfx/cnrs_64px.png"
ICON_CHROME="$DIR_LIBS/gfx/chrome_64px.png"
ICON_CHROMIUM="$DIR_LIBS/gfx/chromium_64px.png"
ICON_FIREFOX="$DIR_LIBS/gfx/firefox_64px.png"
ICON_ICEWEASEL="$DIR_LIBS/gfx/iceweasel_64px.png"

#-------------------------------------------------------------------------------
# Variables d'« environnement » utilisant /run/shm (RAMdisk)
#-------------------------------------------------------------------------------
# Stockage de l'état de la dernier commande 'inist proxy' (1 = on / 0 = off)
IT_ENV_ISPROXY="/run/shm/it_env_isProxy"

#-------------------------------------------------------------------------------
# Logging
# $1 : level/priorité (NOTICE, WARNING, ERROR, etc.)
# $2 : contenu du message ou de l'erreur
#-------------------------------------------------------------------------------
function _it_std_message {
  local MESSAGE="[INIST-TOOLS ($MODULE_VERSION)] $2"
  local MSG_TITLE="[INIST-TOOLS : $1]"
  local MSG_CONTENT="$2"
  
  case "$1" in
  
    # INFORMATION
    info|INFO)
      logger -s -p "$1" "$MESSAGE"
      notify-send --icon="$ICON_CNRS" --urgency=low "INFORMATION" "$MESSAGE"
    ;;
    
    # ALERTE !
    warning|WARNING)
      logger -s -p "$1" "$MESSAGE"
      notify-send --icon=stock_dialog-warning --urgency=normal "ATTENTION !" "$MESSAGE"
    ;;
    
    # ERREUR !
    error|ERROR)
      logger -s -p "$1" "$MESSAGE"
      notify-send --icon=stock_dialog-error --urgency=critical "ERREUR !" "$MESSAGE"
    ;;
    
    # FIREFOX
    firefox|FIREFOX)
      logger -s "$MESSAGE"
      notify-send --icon="$ICON_FIREFOX" --urgency=low "MSG_TITLE" "$MSG_CONTENT"
    ;;

    # ICEWEASEL
    iceweasel|ICEWEASEL)
      logger -s "$MESSAGE"
      notify-send --icon="$ICON_ICEWEASEL" --urgency=low "MSG_TITLE" "$MSG_CONTENT"
    ;;

    # CHROME
    chrome|CHROME)
      logger -s "$MESSAGE"
      notify-send --icon="$ICON_CHROME" --urgency=low "MSG_TITLE" "$MSG_CONTENT"
    ;;

    # CHROMIUM
    chromium|CHROMIUM)
      logger -s "$MESSAGE"
      notify-send --icon="$ICON_CHROMIUM" --urgency=low "MSG_TITLE" "$MSG_CONTENT"
    ;;
    
    # Autre cas
    *)
      logger -s "$MESSAGE"
      notify-send --icon="$ICON_CNRS" --urgency=low "$MSG_TITLE" "$MSG_CONTENT"
    ;;
    
  esac
}

#-------------------------------------------------------------------------------
# Message en console uniquement
# (mais en plus joli)
# $1 : type de message
# $2 : contenu du message
#-------------------------------------------------------------------------------
function  _it_std_consoleMessage {
  case "$1" in

    # Information
    info|INFO)
      printf "${FG_BR_GREEN}[INFO]\t\t${FG_WHITE}$2${RESET_ALL}\n"
    ;;

    # Erreur
    erreur|ERREUR|error|ERROR)
      printf "${FG_BR_RED}[ERREUR]\t${FG_WHITE}$2${RESET_ALL}\n"
    ;;
    
    # Check/OK
    check|CHECK|ok|OK)
      printf "\t\t${FG_BR_GREEN}✔ ${FG_WHITE}$2\n${RESET_ALL}"
    ;;

    # Check/OK
    nocheck|NOCHECK|nok|NOK)
      printf "\t\t${FG_BR_RED}✘ ${FG_WHITE}$2\n${RESET_ALL}"
    ;;
    
    # Tout le reste...
    *)
      printf "\n"
    ;;

  esac
}

#-------------------------------------------------------------------------------
# Message d'accueil (générique, réutilisable)
#-------------------------------------------------------------------------------
function _it_std_greeting {
  # printf "${FG_BR_BLUE}$MODULE_NAME [${FG_BR_WHITE}$MODULE_VERSION]${RESET_ALL}\n"
  if echo -e "$MODULE_NAME [$MODULE_VERSION_SHORT]\n" ; then
    return 0
  fi
}

#-------------------------------------------------------------------------------
# Affichage de la version
#-------------------------------------------------------------------------------
function _it_std_show_version {
  echo -e "$MODULE_NAME est en version ${FG_BR_BLUE}${BG_BLUE}${FS_BOLD}$MODULE_VERSION${RESET_ALL}\nSystème : $HOST_SYSTEM\nVersion : $HOST_SYSTEM_VERSION\n"
}

#-------------------------------------------------------------------------------
# Affichage de l'aide
#-------------------------------------------------------------------------------
function _it_std_show_help {
  cat $DIR_LIBS/inist-tools-help.txt
}

#-------------------------------------------------------------------------------
# Vérification de l'existance d'un binaire
# (retourne 0 si trouvé, 1 si non trouvé)
#-------------------------------------------------------------------------------
function _it_std_check_command {
  if [ ! -z "$1" ]; then
    CHECK=$(which "$1")
    return $?
  fi
  # Argument $1 vide => ERREUR
  return 1
}

#-------------------------------------------------------------------------------
# Crée un backup d'un fichier...
# (notamment avant la modification des confs)
#-------------------------------------------------------------------------------
function _it_std_backup {
  local FILE="$1"
  # On vérifie que c'est bien un fichier
  if [ ! -f "$FILE"]; then
    _it_std_consoleMessage "ERREUR" "« $FILE » n'est pas un fichier"
    return $FALSE
  fi
  
  #
  DIRNAME=$(which dirname)
  BASENAME=$(which basename)
  
  # Chemin absolu du fichier
  local ABS_FILE=$(readlink -f "$FILE")
  
  # Quel est le répertoire de ce fichier ?
  local FILE_DIR=$(DIRNAME "$FILE")
  
  # Quel est le nom de ce fichie ?
  local FILE_NAME=$(BASENAME "$FILE")
  local FILE_NAME_WITHOUT_EXTENSION="${FILE_NAME%.*}"
  
  # Création du nom de backup en fonction de la date du jour
  local TIMESTAMP=$(date +%Y-%m-%d@%H-%M-%S)
  local NEW_FILE_NAME="$FILE_DIR/$FILE_NAME_WITHOUT_EXTENSION.inist.$TIMESTAMP"
  
  # Copie du fichier
  cp "$FILE" "$NEW_FILE_NAME"
  
  # Vérification de la copie
  if [ "$?" -gt 0 ]; then
    _it_std_consoleMessage "ERREUR" "La copie de « $FILE » vers « $NEW_FILE_NAME » n'a pas fonctionné."
    return $FALSE
  fi
}

#-------------------------------------------------------------------------------
# Restaure un fichier backupé avec la fonction « _it_std_backup »
# (recherche automatiquement dans l'arborescence indiquée en argument
# un fichier de backup et le restaure)
#-------------------------------------------------------------------------------
function _it_std_restore {
  WHERETOFIND="$1"
  if [ ! -d "$WHERETOFIND" ]; then
    _it_std_consoleMessage "ERROR" "« $WHERETOFIND » n'est pas un répertoire"
    return $FALSE
  fi
  
  BACKUPFILE=$(find "$WHERETOFIND" -type f -name "*.")
  
}

#-------------------------------------------------------------------------------
# Vérification du dockage du portable...
# ...en comptant les hub USB dispo
# ...en comptant les écrans connectés
# /!\ Pss fiable à 100% (et il faut que xrandr soit installé)
#-------------------------------------------------------------------------------
#function _it_std_check_docked {
  #USBHUBS_COUNT=$(lsusb | grep "hub" | wc -l)
  #DISPLAY_COUNT=$(xrandr | grep " connected" | wc -l)
  #if [ $USBHUBS_COUNT -eq 4 ] && [ $DISPLAY_COUNT -gt 1 ]; then
    #IS_DOCKED=0
    #return 0
  #else
    #IS_DOCKED=1
    #return 1
  #fi
#}
